/**
 * @file main.c
 * @brief Rate PID & Mixer Validation Firmware
 *
 * PURPOSE:
 * Validate the INNER (RATE) PID control loop and Motor Mixing.
 *
 * TEST PROCEDURE (NO PROPS!):
 * 1. Power on.
 * 2. System initializes (IMU, PWM, ADC).
 * 3. Gyro calibrates (Keep still).
 * 4. Safety Check: Battery voltage.
 * 5. ARMING SEQUENCE:
 *    - Wait 5 seconds.
 *    - Arm motors at IDLE speed.
 * 6. LOOP:
 *    - Read Gyro.
 *    - Run Rate PID (Target = 0 deg/s).
 *    - Mix outputs (Throttle = Idle).
 *    - Send to Motors.
 *    - Verify motors react to movement (correct direction).
 *
 * SAFETY:
 * - Low battery cutoff.
 * - Crash angle protection (disarm if > 60 deg tilt).
 * - Kill switch (Boot button GPIO 0).
 */

#include "driver/gpio.h"
#include "esp_attr.h"
#include "esp_err.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

#include "../lib/blackbox/blackbox.h"
#include "../lib/config/config.h"
#include "../lib/rx/rx.h"
#include "../lib/webserver/webserver.h"
#include "adc.h"
#include "angle_control.h"
#include "imu.h"
#include "mixer.h"
#include "pwm.h"
#include "rate_control.h"

/* -------------------------------------------------------------------------- */
/*                               Configuration                                */
/* -------------------------------------------------------------------------- */

// Status LED
#define LED_PIN 2
#define BUTTON_PIN 0 // Boot button for emergency stop

// Control loop frequency (250 Hz)
#define CONTROL_LOOP_FREQ_HZ 250
#define CONTROL_LOOP_PERIOD_US (1000000 / CONTROL_LOOP_FREQ_HZ)

// Debug print frequency (10 Hz) -> 250 / 25 = 10
#define DEBUG_PRINT_DIVIDER 25

// RC Mapping
#define RC_MAX_ANGLE_DEG 45.0f
#define RC_MAX_YAW_RATE_DPS 180.0f
#define RC_DEADBAND_US 20

/* -------------------------------------------------------------------------- */
/*                               Global State                                 */
/* -------------------------------------------------------------------------- */

static volatile bool control_loop_flag = false;
static int debug_counter = 0;
static int blackbox_counter = 0; // Counter for 50Hz blackbox logging

// System State
bool system_armed = false;
static bool error_state = false;

// Debug data
static float debug_gyro[3];
static float debug_angle[2]; // Roll, Pitch
static float debug_pid[3];
static uint16_t debug_motors[4];
static uint16_t debug_vbat = 0;
static int64_t debug_exec_time_us = 0;

/* -------------------------------------------------------------------------- */
/*                          Control Loop (500 Hz Timer)                       */
/* -------------------------------------------------------------------------- */

static void IRAM_ATTR control_loop_callback(void *arg) {
  (void)arg;

  int64_t start_time = esp_timer_get_time();

  // 1. Read IMU
  imu_read(1.0f / CONTROL_LOOP_FREQ_HZ);
  const imu_data_t *imu = imu_get_data();

  // 2. Safety Checks (Crash detection)
  // Angle-based: if roll or pitch angle is too high, disarm
  if (fabs(imu->roll_deg) > sys_cfg.crash_angle_deg ||
      fabs(imu->pitch_deg) > sys_cfg.crash_angle_deg) {
    mixer_arm(false);
    system_armed = false;
    error_state = true;
  }

  // Gyro rate-based: detect rapid rotation (impact/crash) even if filtered
  // angles lag 500 deg/s threshold catches most crash scenarios
  const float CRASH_GYRO_RATE_DPS = 500.0f;
  if (fabs(imu->gyro_x_dps) > CRASH_GYRO_RATE_DPS ||
      fabs(imu->gyro_y_dps) > CRASH_GYRO_RATE_DPS ||
      fabs(imu->gyro_z_dps) > CRASH_GYRO_RATE_DPS) {
    mixer_arm(false);
    system_armed = false;
    error_state = true;
  }

  // 3. Read RX Channels
  uint16_t rx_roll = rx_get_channel(0);
  uint16_t rx_pitch = rx_get_channel(1);
  uint16_t rx_thr = rx_get_channel(2);
  uint16_t rx_yaw = rx_get_channel(3);

  // Map Yaw (always rate controlled)
  float target_yaw_rate = 0.0f;
  if (abs(rx_yaw - 1500) > RC_DEADBAND_US) {
    target_yaw_rate = (float)(rx_yaw - 1500) / 500.0f * RC_MAX_YAW_RATE_DPS;
  }

  // Map Roll/Pitch Stick -> Angle Target
  float target_roll = 0.0f;
  if (abs(rx_roll - 1500) > RC_DEADBAND_US) {
    target_roll = (float)(rx_roll - 1500) / 500.0f * RC_MAX_ANGLE_DEG;
  }

  float target_pitch = 0.0f;
  if (abs(rx_pitch - 1500) > RC_DEADBAND_US) {
    target_pitch = (float)(rx_pitch - 1500) / 500.0f * RC_MAX_ANGLE_DEG;
  }

  // 4. Cascade Control: Angle -> Rate
  // Angle loop output = rate setpoint for Rate loop
  // When Angle P = 0, angle_control outputs 0, so Rate loop targets 0 deg/s
  angle_control_update(imu->roll_deg, imu->pitch_deg, target_roll, target_pitch,
                       1.0f / CONTROL_LOOP_FREQ_HZ);
  const angle_output_t *angle_out = angle_control_get_output();

  // Rate loop: try to achieve the rate setpoint from angle loop (0 when P=0)
  rate_control_update(angle_out->roll_rate_setpoint,
                      angle_out->pitch_rate_setpoint, target_yaw_rate,
                      imu->gyro_x_dps, imu->gyro_y_dps, imu->gyro_z_dps);

  // 5. Update Mixer
  const rate_output_t *pid_out = rate_control_get_output();

  // Throttle:
  // DIRECT RX CONTROL
  // If armed, use the mapped RX throttle.
  // If disarmed, mixer handles it (stops).
  uint16_t throttle = system_armed ? rx_thr : 1000;

  // Safety: Ensure throttle doesn't drop below min or exceed max
  if (throttle < 1000)
    throttle = 1000;
  if (throttle > 2000)
    throttle = 2000;

  mixer_update(throttle, pid_out->roll, pid_out->pitch, pid_out->yaw);

  int64_t end_time = esp_timer_get_time();

  // 5. Store Debug Data
  if (++debug_counter >= DEBUG_PRINT_DIVIDER) {
    debug_counter = 0;
    control_loop_flag = true;

    debug_gyro[0] = imu->gyro_x_dps;
    debug_gyro[1] = imu->gyro_y_dps;
    debug_gyro[2] = imu->gyro_z_dps;

    debug_angle[0] = imu->roll_deg;
    debug_angle[1] = imu->pitch_deg;

    debug_pid[0] = pid_out->roll;
    debug_pid[1] = pid_out->pitch;
    debug_pid[2] = pid_out->yaw;

    mixer_get_outputs(&debug_motors[0], &debug_motors[1], &debug_motors[2],
                      &debug_motors[3]);

    debug_exec_time_us = end_time - start_time;
  }

  // 6. Blackbox Logging (50Hz - every 10th iteration) - ONLY WHEN ARMED
  if (system_armed && ++blackbox_counter >= BLACKBOX_LOG_DIVIDER) {
    blackbox_counter = 0;

    blackbox_entry_t entry = {
        .timestamp_ms = (uint32_t)(esp_timer_get_time() / 1000),
        .gyro_x = imu->gyro_x_dps,
        .gyro_y = imu->gyro_y_dps,
        .gyro_z = imu->gyro_z_dps,
        .angle_roll = imu->roll_deg,
        .angle_pitch = imu->pitch_deg,
        .pid_roll = pid_out->roll,
        .pid_pitch = pid_out->pitch,
        .pid_yaw = pid_out->yaw,
        .motor = {debug_motors[0], debug_motors[1], debug_motors[2],
                  debug_motors[3]},
        .throttle = throttle,
        .flags = (system_armed ? BLACKBOX_FLAG_ARMED : 0) |
                 (error_state ? BLACKBOX_FLAG_ERROR : 0)};
    blackbox_log(&entry);
  } else if (!system_armed) {
    blackbox_counter = 0; // Reset counter when disarmed
  }
}

/* -------------------------------------------------------------------------- */
/*                                 Main Entry                                 */
/* -------------------------------------------------------------------------- */

void app_main(void) {
  // ========== CRITICAL: ESC BOOT FIX ==========
  // Configure motor GPIOs as OUTPUT LOW immediately to prevent
  // ESCs from seeing floating signals during ESP32 boot.
  // This happens BEFORE any other initialization!
  gpio_reset_pin(PWM_MOTOR_1_GPIO); // Motor 1
  gpio_reset_pin(PWM_MOTOR_2_GPIO); // Motor 2
  gpio_reset_pin(PWM_MOTOR_3_GPIO); // Motor 3
  gpio_reset_pin(PWM_MOTOR_4_GPIO); // Motor 4
  gpio_set_direction(PWM_MOTOR_1_GPIO, GPIO_MODE_OUTPUT);
  gpio_set_direction(PWM_MOTOR_2_GPIO, GPIO_MODE_OUTPUT);
  gpio_set_direction(PWM_MOTOR_3_GPIO, GPIO_MODE_OUTPUT);
  gpio_set_direction(PWM_MOTOR_4_GPIO, GPIO_MODE_OUTPUT);
  gpio_set_level(PWM_MOTOR_1_GPIO, 0);
  gpio_set_level(PWM_MOTOR_2_GPIO, 0);
  gpio_set_level(PWM_MOTOR_3_GPIO, 0);
  gpio_set_level(PWM_MOTOR_4_GPIO, 0);

  // Now init PWM properly (will take over these pins)
  pwm_init();

  // Send stable IDLE signal to all motors for 3 seconds
  for (int i = 0; i < 4; i++) {
    pwm_set_motor(i, 1000);
  }
  vTaskDelay(pdMS_TO_TICKS(3000)); // ESC arm time
  // ========== END ESC BOOT FIX ==========

  // 1. Init NVS
  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES ||
      ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
  }
  ESP_ERROR_CHECK(ret);

  // Load Configuration
  config_load_defaults();
  config_load_from_nvs(); // Load saved values from flash (if any)

  // 2. Init GPIO
  gpio_reset_pin(LED_PIN);
  gpio_set_direction(LED_PIN, GPIO_MODE_OUTPUT);

  gpio_reset_pin(BUTTON_PIN);
  gpio_set_direction(BUTTON_PIN, GPIO_MODE_INPUT);
  gpio_set_pull_mode(BUTTON_PIN, GPIO_PULLUP_ONLY);

  // 3. Init Subsystems
  adc_init();

  rx_init();
  mixer_init();
  blackbox_init();  // RAM-based flight data logger
  webserver_init(); // WiFi AP + PID tuning web interface

  if (imu_init() != ESP_OK) {
    printf("IMU Init Failed!\n");
    while (1)
      vTaskDelay(100);
  }

  // 4. Gyro/Accel Calibration (load from NVS if available)
  if (imu_calibration_load_from_nvs()) {
    printf("IMU Calibration loaded from NVS.\n");
  } else {
    printf("Calibrating Gyro... Keep Still.\n");
    vTaskDelay(pdMS_TO_TICKS(1000));
    imu_calibrate_gyro();
    printf("Gyro Calibrated.\n");

    printf("Calibrating Accel... Keep Level.\n");
    imu_calibrate_accel();
    printf("Accel Calibrated.\n");

    // Save calibration to NVS for next boot
    imu_calibration_save_to_nvs();
    printf("Calibration saved to NVS.\n");
  }

  // 5. Init Control Loops
  rate_control_init();
  angle_control_init();

  // 6. Start Control Loop
  const esp_timer_create_args_t timer_args = {
      .callback = &control_loop_callback,
      .name = "control_loop",
      .dispatch_method = ESP_TIMER_TASK,
  };
  esp_timer_handle_t control_timer;
  ESP_ERROR_CHECK(esp_timer_create(&timer_args, &control_timer));
  ESP_ERROR_CHECK(
      esp_timer_start_periodic(control_timer, CONTROL_LOOP_PERIOD_US));

  printf("Control Loop Started.\n");

  // 8. Main Loop (Monitoring & Arming)
  while (1) {
    // 7. Arming & Safety Logic (RX Channel 5) - runs every iteration
    bool rx_ok = rx_is_connected();
    uint16_t rx_aux1 = rx_get_channel(4);    // Channel 5 (0-indexed is 4)
    bool arm_switch_high = (rx_aux1 > 1600); // Threshold for arming

    // Arming State Machine
    if (rx_ok && arm_switch_high && !error_state) {
      if (!system_armed) {
        // Check throttle safety before arming
        uint16_t rx_thr_check = rx_get_channel(2);
        if (rx_thr_check < 1150) { // Throttle must be low to arm
          system_armed = true;

          // Reset PIDs to prevent I-term windup from ground handling
          rate_control_init();
          angle_control_init();

          mixer_arm(true);
          blackbox_clear(); // Clear old data
          blackbox_start(); // Start recording new flight
          printf("ARMED! (Switch High)\n");
        } else {
          static int warn_counter = 0;
          if (warn_counter++ % 50 == 0)
            printf("CANNOT ARM: Throttle not low!\n");
        }
      }
    } else {
      if (system_armed) {
        system_armed = false;
        mixer_arm(false);
        blackbox_stop(); // Stop recording, preserve data for download
        if (!rx_ok)
          printf("DISARMED! (RX Signal Lost)\n");
        else
          printf("DISARMED! (Switch Low)\n");
      }

      // Clear error state if disarmed and switch is low (allow re-arming)
      if (error_state && !arm_switch_high) {
        error_state = false;
        printf("Error State Cleared. Ready to Arm.\n");
      }
    }

    // LED Status
    gpio_set_level(LED_PIN, system_armed ? 1 : 0);

    // Check Emergency Stop Button
    if (gpio_get_level(BUTTON_PIN) == 0) {
      system_armed = false;
      mixer_arm(false);
      printf("EMERGENCY STOP TRIGGERED!\n");
      error_state = true;
    }

    // Low Battery Check (Slow)
    debug_vbat = adc_read_battery_voltg();
    if (system_armed && debug_vbat < sys_cfg.low_bat_threshold) {
      // Debounce could be added here, but for safety, immediate warning/disarm
      // For now, just print warning, maybe disarm if critical
      if (debug_vbat < 9500) { // Critical 9.5V
        system_armed = false;
        mixer_arm(false);
        printf("CRITICAL BATTERY! DISARMED.\n");
      }
    }

    if (control_loop_flag) {
      control_loop_flag = false;

      uint16_t rx_ch[RX_CHANNEL_COUNT];
      rx_get_all(rx_ch);

      // Debug print commented out to reduce loop time
      // printf("A: %5.1f %5.1f | G: %6.1f %6.1f %6.1f | P: %5.1f %5.1f %5.1f |
      // "
      //        "M: %4d %4d %4d %4d | RX: %4d %4d %4d %4d %4d %4d "
      //        "| V: %d | T: %lld us\n",
      //        debug_angle[0], debug_angle[1], debug_gyro[0], debug_gyro[1],
      //        debug_gyro[2], debug_pid[0], debug_pid[1], debug_pid[2],
      //        debug_motors[0], debug_motors[1], debug_motors[2],
      //        debug_motors[3], rx_ch[0], rx_ch[1], rx_ch[2], rx_ch[3],
      //        rx_ch[4], rx_ch[5], debug_vbat, debug_exec_time_us);

      // if (error_state) {
      //   printf("!!! SYSTEM ERROR / DISARMED !!!\n");
      // }
    }

    vTaskDelay(pdMS_TO_TICKS(10));
  }
}
