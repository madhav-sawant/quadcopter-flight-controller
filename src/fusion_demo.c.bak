/**
 * VL53L0X & BMP280 Sensor Display - ESP32
 * Shows distance (mm) and pressure/altitude
 */
#include "../lib/baro/baro.h"
#include "../lib/vl53l0x/vl53l0x.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <stdio.h>

#define TAG "MAIN"

static vl53l0x_t vl53_sensor;

void app_main(void) {
  ESP_LOGI(TAG, "--- Sensor Display Demo ---");

  // 1. Initialize I2C (shared bus)
  // vl53l0x_i2c_init() installs the I2C driver on I2C_NUM_0
  if (vl53l0x_i2c_init() != ESP_OK) {
    ESP_LOGE(TAG, "I2C Init Failed");
    return;
  }

  // 2. Initialize VL53L0X Laser Sensor
  if (vl53l0x_init(&vl53_sensor) != ESP_OK) {
    ESP_LOGE(TAG, "VL53L0X Init Failed");
  } else {
    ESP_LOGI(TAG, "VL53L0X Init Success");
    vl53l0x_start_continuous(&vl53_sensor);
  }

  // 3. Initialize BMP280 Barometer
  // baro_init() assumes I2C driver is already installed (which we did above)
  if (baro_init() != ESP_OK) {
    ESP_LOGE(TAG, "Baro Init Failed");
  } else {
    ESP_LOGI(TAG, "Baro Init Success");
  }

  // 4. Calibrate Barometer (Zeroing) which essentially sets the initial ground
  // pressure
  ESP_LOGI(TAG, "Calibrating Barometer (Ground Ref)... Keep Still!");
  float start_alt_sum = 0.0f;
  const int samples = 50;
  for (int i = 0; i < samples; i++) {
    baro_read();
    start_alt_sum += baro_get_data()->altitude_m;
    vTaskDelay(pdMS_TO_TICKS(20));
  }
  // This is just a rough ground ref for the "Raw Baro Rel" display
  float ground_alt_ref = start_alt_sum / samples;
  ESP_LOGI(TAG, "Calibration Done. Ground Ref: %.2f m", ground_alt_ref);
  vTaskDelay(pdMS_TO_TICKS(2000)); // Pause to read calibration

  // FUSION STATE VARIABLES
  float baro_offset_m = 0.0f;
  float fused_alt_m = 0.0f;
  bool using_laser = true;
  bool offset_locked = false; // NEW: Track if we have locked the offset
  const float FUSION_THRESH_M = 0.15f; // 15cm Threshold

  ESP_LOGI(TAG, "Starting Sensor Fusion Loop (One-Shot Lock @ %.2fm)...",
           FUSION_THRESH_M);

  while (1) {
    // 1. READ SENSORS
    // ----------------
    uint16_t dist_mm = 0;
    esp_err_t ret = vl53l0x_read_continuous(&vl53_sensor, &dist_mm);
    bool laser_valid = (ret == ESP_OK) && (dist_mm < 8190);
    float laser_m = (float)dist_mm / 1000.0f;

    baro_read();
    const baro_data_t *baro = baro_get_data();
    float baro_rel_m = baro->altitude_m - ground_alt_ref;

    // 2. FUSION LOGIC (LATCHING)
    // --------------------------

    // CASE A: BELOW THRESHOLD (Laser Domain)
    if (laser_valid && laser_m < FUSION_THRESH_M) {
      using_laser = true;

      // 1. Use Laser directly
      fused_alt_m = laser_m;

      // 2. Reset the lock (we are back on the "ground" / low alt)
      // We will strictly re-calculate offset when we cross 15cm again.
      offset_locked = false;

      // We do NOT update baro_offset_m here. We ignore Baro glitches.

    }
    // CASE B: ABOVE THRESHOLD (Baro Domain)
    else {
      using_laser = false;

      // 1. Check if we just transitioned? (Not locked yet)
      if (!offset_locked) {
        // SNAPSHOT! ONE TIME EVENT!
        // We assume we are EXACTLY at the threshold (e.g. 15cm) right now.
        // Force Baro curve to match this point.
        // Offset = Current_Baro - Target_Height (15cm)
        baro_offset_m = baro_rel_m - FUSION_THRESH_M;

        offset_locked = true;
        ESP_LOGI(TAG, "LOCKED Offset: %.3f m (Baro: %.3f, Target: %.3f)",
                 baro_offset_m, baro_rel_m, FUSION_THRESH_M);
      }

      // 2. Use Baro with the Locked Offset
      fused_alt_m = baro_rel_m - baro_offset_m;
    }

    // 3. DISPLAY
    // ----------
    printf("\033[2J\033[H"); // Clear
    printf("--- ALTITUDE FUSION (LATCHING) ---\n");
    printf("Threshold: %.1f cm\n", FUSION_THRESH_M * 100.0f);
    printf("----------------------------\n");

    if (laser_valid)
      printf("LASER     : %6.1f cm\n", laser_m * 100.0f);
    else
      printf("LASER     : [INVALID]\n");

    printf("BARO (AGL): %6.1f cm\n", baro_rel_m * 100.0f);

    if (offset_locked)
      printf("OFFSET    : %6.1f cm  [LOCKED]\n", baro_offset_m * 100.0f);
    else
      printf("OFFSET    : [WAITING] (Ignoring Baro)\n");

    printf("----------------------------\n");

    if (using_laser)
      printf("MODE      : [ LASER ]\n");
    else
      printf("MODE      : [ BARO  ] (Offset Applied)\n");

    printf("----------------------------\n");
    printf("FUSED ALT : %6.1f cm\n", fused_alt_m * 100.0f);
    printf("----------------------------\n");

    vTaskDelay(pdMS_TO_TICKS(200)); // 5Hz update
  }
}
